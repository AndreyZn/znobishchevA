.data
printf_format:
        .string "%d\n"

array:
        .long 10, 15, 148, 12, 151, 3, 72
array_end:

.text
.globl main
main:
        movl  $100500, %eax          /* в %eax будет храниться результат;
                                   в начале наименьшее значение — 0  */
        movl  $array, %ebx      /* в %ebx находится адрес текущего
                                   элемента массива                  */

loop_start:                     /* начало цикла                      */
        cmpl  %eax, (%ebx)      /* сравнить текущий элемент массива с
                                /*   текущим наменььшим значением из %eax
                                                                     */
        jae   more              /* если текущий элемент массива больше
                                  /* или равен наименьшему, пропустить
                                   следующий код                     */
        movl  (%ebx), %eax      /* а если элемент массива
                                   меньше наименьшего, значит, его
                                   значение и есть новый миниммум    */
more:
        addl  $4, %ebx          /* увеличить %ebx на размер одного
                                   элемента массива, 4 байта         */
        cmpl  $array_end, %ebx  /* сравнить адрес текущего элемента и
                                   адрес конца массива               */
        je    loop_end          /* если они равны, выйти из цикла    */
        jmp   loop_start        /* иначе повторить цикл снова        */
loop_end:

/*
 * следующий код выводит число из %eax на экран и завершает программу
 */
        pushl %eax
        pushl $printf_format
        call  printf
        addl  $8, %esp

        movl  $0, %eax
        ret
